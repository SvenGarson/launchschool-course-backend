# Debugging, with pry #

- pry in terminal instead irb
- cd into an object in pry
- ls to check methods
- cd .. to return back up and cd / to get
  bac to main 


- require 'pry' and call binding.pry to
  inspect the program at halted runtime 

- can access but not the definition of objects
  below the binding.pry cal

- binding.pry returns nil (and other values/objects?)
  depending on where the pry is called!

- press 'control-D' or type 'exit'to return to the
  executing program and type 'exit-programm' to exit
  pry and stop executing the program

- whereami to show where the binding call is at in
  the context of the program. 'whereami' takes and argument
  for how many lines over/below to show

- workflow:
  - require pry
  - call pry in the code (return value of pry!!!)
  - check variables, call methods etc
  - step through code

# pry-byebug #

- require 'pry-byebug'
- extends pry with following commands: 
  - next
  - step
  - continue
  - breakpoint
  - ... see github pry-byebug project and cheat-sheet
- use the same 'binding.pry' as before

# Other similar gems #
- pry-nav
- pry-debugger

# starting a project #

# === P : understand the problem + mental model === #
# === E : example, test, edge cases === #
  1) Rough description
  2) Rough pseudo code, more detailed than (1)
# === DA: datastructured and algorithms ===
  3) Flowchart with sub-processes
  4) More formal pseudo-code or lower level flowchart
# === C : code with intent ===

Also flowchart the types of variables etc. used
